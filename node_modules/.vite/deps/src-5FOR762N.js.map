{
  "version": 3,
  "sources": ["../../@humanfs/core/src/hfs.js", "../../@humanfs/core/src/path.js", "../../@humanfs/core/src/errors.js", "../../@humanfs/core/src/index.js", "../../@humanwhocodes/retry/dist/retrier.js", "../../@humanfs/node/src/node-hfs.js", "../../@humanfs/node/src/index.js"],
  "sourcesContent": ["/**\n * @fileoverview The main file for the humanfs package.\n * @author Nicholas C. Zakas\n */\n\n/* global URL, TextDecoder, TextEncoder */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"@humanfs/types\").HfsWalkEntry} HfsWalkEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n\n/**\n * Error to represent when a method is missing on an impl.\n */\nexport class NoSuchMethodError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" does not exist on impl.`);\n\t}\n}\n\n/**\n * Error to represent when a method is not supported on an impl. This happens\n * when a method on `Hfs` is called with one name and the corresponding method\n * on the impl has a different name. (Example: `text()` and `bytes()`.)\n */\nexport class MethodNotSupportedError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" is not supported on this impl.`);\n\t}\n}\n\n/**\n * Error to represent when an impl is already set.\n */\nexport class ImplAlreadySetError extends Error {\n\t/**\n\t * Creates a new instance.\n\t */\n\tconstructor() {\n\t\tsuper(`Implementation already set.`);\n\t}\n}\n\n/**\n * Asserts that the given path is a valid file path.\n * @param {any} fileOrDirPath The path to check.\n * @returns {void}\n * @throws {TypeError} When the path is not a non-empty string.\n */\nfunction assertValidFileOrDirPath(fileOrDirPath) {\n\tif (\n\t\t!fileOrDirPath ||\n\t\t(!(fileOrDirPath instanceof URL) && typeof fileOrDirPath !== \"string\")\n\t) {\n\t\tthrow new TypeError(\"Path must be a non-empty string or URL.\");\n\t}\n}\n\n/**\n * Asserts that the given file contents are valid.\n * @param {any} contents The contents to check.\n * @returns {void}\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction assertValidFileContents(contents) {\n\tif (\n\t\ttypeof contents !== \"string\" &&\n\t\t!(contents instanceof ArrayBuffer) &&\n\t\t!ArrayBuffer.isView(contents)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t\"File contents must be a string, ArrayBuffer, or ArrayBuffer view.\",\n\t\t);\n\t}\n}\n\n/**\n * Converts the given contents to Uint8Array.\n * @param {any} contents The data to convert.\n * @returns {Uint8Array} The converted Uint8Array.\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction toUint8Array(contents) {\n\tif (contents instanceof Uint8Array) {\n\t\treturn contents;\n\t}\n\n\tif (typeof contents === \"string\") {\n\t\treturn encoder.encode(contents);\n\t}\n\n\tif (contents instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(contents);\n\t}\n\n\tif (ArrayBuffer.isView(contents)) {\n\t\tconst bytes = contents.buffer.slice(\n\t\t\tcontents.byteOffset,\n\t\t\tcontents.byteOffset + contents.byteLength,\n\t\t);\n\t\treturn new Uint8Array(bytes);\n\t}\n\tthrow new TypeError(\n\t\t\"Invalid contents type. Expected string or ArrayBuffer.\",\n\t);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a log entry.\n */\nexport class LogEntry {\n\t/**\n\t * The type of log entry.\n\t * @type {string}\n\t */\n\ttype;\n\n\t/**\n\t * The data associated with the log entry.\n\t * @type {any}\n\t */\n\tdata;\n\n\t/**\n\t * The time at which the log entry was created.\n\t * @type {number}\n\t */\n\ttimestamp = Date.now();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} type The type of log entry.\n\t * @param {any} [data] The data associated with the log entry.\n\t */\n\tconstructor(type, data) {\n\t\tthis.type = type;\n\t\tthis.data = data;\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class Hfs {\n\t/**\n\t * The base implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#baseImpl;\n\n\t/**\n\t * The current implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#impl;\n\n\t/**\n\t * A map of log names to their corresponding entries.\n\t * @type {Map<string,Array<LogEntry>>}\n\t */\n\t#logs = new Map();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} options The options for the instance.\n\t * @param {HfsImpl} options.impl The implementation to use.\n\t */\n\tconstructor({ impl }) {\n\t\tthis.#baseImpl = impl;\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Logs an entry onto all currently open logs.\n\t * @param {string} methodName The name of the method being called.\n\t * @param {...*} args The arguments to the method.\n\t * @returns {void}\n\t */\n\t#log(methodName, ...args) {\n\t\tfor (const logs of this.#logs.values()) {\n\t\t\tlogs.push(new LogEntry(\"call\", { methodName, args }));\n\t\t}\n\t}\n\n\t/**\n\t * Starts a new log with the given name.\n\t * @param {string} name The name of the log to start;\n\t * @returns {void}\n\t * @throws {Error} When the log already exists.\n\t * @throws {TypeError} When the name is not a non-empty string.\n\t */\n\tlogStart(name) {\n\t\tif (!name || typeof name !== \"string\") {\n\t\t\tthrow new TypeError(\"Log name must be a non-empty string.\");\n\t\t}\n\n\t\tif (this.#logs.has(name)) {\n\t\t\tthrow new Error(`Log \"${name}\" already exists.`);\n\t\t}\n\n\t\tthis.#logs.set(name, []);\n\t}\n\n\t/**\n\t * Ends a log with the given name and returns the entries.\n\t * @param {string} name The name of the log to end.\n\t * @returns {Array<LogEntry>} The entries in the log.\n\t * @throws {Error} When the log does not exist.\n\t */\n\tlogEnd(name) {\n\t\tif (this.#logs.has(name)) {\n\t\t\tconst logs = this.#logs.get(name);\n\t\t\tthis.#logs.delete(name);\n\t\t\treturn logs;\n\t\t}\n\n\t\tthrow new Error(`Log \"${name}\" does not exist.`);\n\t}\n\n\t/**\n\t * Determines if the current implementation is the base implementation.\n\t * @returns {boolean} True if the current implementation is the base implementation.\n\t */\n\tisBaseImpl() {\n\t\treturn this.#impl === this.#baseImpl;\n\t}\n\n\t/**\n\t * Sets the implementation for this instance.\n\t * @param {object} impl The implementation to use.\n\t * @returns {void}\n\t */\n\tsetImpl(impl) {\n\t\tthis.#log(\"implSet\", impl);\n\n\t\tif (this.#impl !== this.#baseImpl) {\n\t\t\tthrow new ImplAlreadySetError();\n\t\t}\n\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Resets the implementation for this instance back to its original.\n\t * @returns {void}\n\t */\n\tresetImpl() {\n\t\tthis.#log(\"implReset\");\n\t\tthis.#impl = this.#baseImpl;\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation.\n\t * @param {string} methodName The name of the method to check.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethod(methodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new NoSuchMethodError(methodName);\n\t\t}\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation, and if not,\n\t * throws an error with a different method name.\n\t * @param {string} methodName The name of the method to check.\n\t * @param {string} targetMethodName The name of the method that should be reported\n\t *  as an error when methodName does not exist.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethodAlt(methodName, targetMethodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new MethodNotSupportedError(targetMethodName);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethod(methodName, ...args) {\n\t\tthis.#log(methodName, ...args);\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation and doesn't log the call.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodWithoutLog(methodName, ...args) {\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation but logs a different method name.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {string} targetMethodName The name of the method to log.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodAlt(methodName, targetMethodName, ...args) {\n\t\tthis.#log(targetMethodName, ...args);\n\t\tthis.#assertImplMethodAlt(methodName, targetMethodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<string|undefined>} The contents of the file.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync text(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"text\", filePath);\n\t\treturn result ? decoder.decode(result) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<any|undefined>} The contents of the file as JSON.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {SyntaxError} When the file contents are not valid JSON.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync json(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"json\", filePath);\n\t\treturn result ? JSON.parse(decoder.decode(result)) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an ArrayBuffer.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @deprecated Use bytes() instead.\n\t */\n\tasync arrayBuffer(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\n\t\t\t\"bytes\",\n\t\t\t\"arrayBuffer\",\n\t\t\tfilePath,\n\t\t);\n\t\treturn result?.buffer;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync bytes(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"bytes\", filePath);\n\t}\n\n\t/**\n\t * Writes the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to write.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to write.\n\t * @returns {Promise<void>} A promise that resolves when the file is written.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync write(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"write\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"write\", filePath, value);\n\t}\n\n\t/**\n\t * Appends the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to append to.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to append.\n\t * @returns {Promise<void>} A promise that resolves when the file is appended to.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @throws {TypeError} When the file contents are not a string or ArrayBuffer.\n\t * @throws {Error} When the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"append\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"append\", filePath, value);\n\t}\n\n\t/**\n\t * Determines if the given file exists.\n\t * @param {string|URL} filePath The file to check.\n\t * @returns {Promise<boolean>} True if the file exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync isFile(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"isFile\", filePath);\n\t}\n\n\t/**\n\t * Determines if the given directory exists.\n\t * @param {string|URL} dirPath The directory to check.\n\t * @returns {Promise<boolean>} True if the directory exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync isDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"isDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Creates the given directory.\n\t * @param {string|URL} dirPath The directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is created.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"createDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Deletes the given file or empty directory.\n\t * @param {string|URL} filePath The file to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync delete(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"delete\", filePath);\n\t}\n\n\t/**\n\t * Deletes the given file or directory recursively.\n\t * @param {string|URL} dirPath The directory to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync deleteAll(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"deleteAll\", dirPath);\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tyield* await this.#callImplMethod(\"list\", dirPath);\n\t}\n\n\t/**\n\t * Walks a directory using a depth-first traversal and returns the entries\n\t * from the traversal.\n\t * @param {string|URL} dirPath The path to the directory to walk.\n\t * @param {Object} [options] The options for the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.directoryFilter] A filter function to determine\n\t * \tif a directory's entries should be included in the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.entryFilter] A filter function to determine if\n\t * \tan entry should be included in the walk.\n\t * @returns {AsyncIterable<HfsWalkEntry>} A promise that resolves with the\n\t * \tdirectory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *walk(\n\t\tdirPath,\n\t\t{ directoryFilter = () => true, entryFilter = () => true } = {},\n\t) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tthis.#log(\"walk\", dirPath, { directoryFilter, entryFilter });\n\n\t\t// inner function for recursion without additional logging\n\t\tconst walk = async function* (\n\t\t\tdirPath,\n\t\t\t{ directoryFilter, entryFilter, parentPath = \"\", depth = 1 },\n\t\t) {\n\t\t\tlet dirEntries;\n\n\t\t\ttry {\n\t\t\t\tdirEntries = await this.#callImplMethodWithoutLog(\n\t\t\t\t\t\"list\",\n\t\t\t\t\tdirPath,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\t// if the directory does not exist then return an empty array\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// otherwise, rethrow the error\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tfor await (const listEntry of dirEntries) {\n\t\t\t\tconst walkEntry = {\n\t\t\t\t\tpath: listEntry.name,\n\t\t\t\t\tdepth,\n\t\t\t\t\t...listEntry,\n\t\t\t\t};\n\n\t\t\t\tif (parentPath) {\n\t\t\t\t\twalkEntry.path = `${parentPath}/${walkEntry.path}`;\n\t\t\t\t}\n\n\t\t\t\t// first emit the entry but only if the entry filter returns true\n\t\t\t\tlet shouldEmitEntry = entryFilter(walkEntry);\n\t\t\t\tif (shouldEmitEntry.then) {\n\t\t\t\t\tshouldEmitEntry = await shouldEmitEntry;\n\t\t\t\t}\n\n\t\t\t\tif (shouldEmitEntry) {\n\t\t\t\t\tyield walkEntry;\n\t\t\t\t}\n\n\t\t\t\t// if it's a directory then yield the entry and walk the directory\n\t\t\t\tif (listEntry.isDirectory) {\n\t\t\t\t\t// if the directory filter returns false, skip the directory\n\t\t\t\t\tlet shouldWalkDirectory = directoryFilter(walkEntry);\n\t\t\t\t\tif (shouldWalkDirectory.then) {\n\t\t\t\t\t\tshouldWalkDirectory = await shouldWalkDirectory;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shouldWalkDirectory) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make sure there's a trailing slash on the directory path before appending\n\t\t\t\t\tconst directoryPath =\n\t\t\t\t\t\tdirPath instanceof URL\n\t\t\t\t\t\t\t? new URL(\n\t\t\t\t\t\t\t\t\tlistEntry.name,\n\t\t\t\t\t\t\t\t\tdirPath.href.endsWith(\"/\")\n\t\t\t\t\t\t\t\t\t\t? dirPath.href\n\t\t\t\t\t\t\t\t\t\t: `${dirPath.href}/`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: `${dirPath.endsWith(\"/\") ? dirPath : `${dirPath}/`}${listEntry.name}`;\n\n\t\t\t\t\tyield* walk(directoryPath, {\n\t\t\t\t\t\tdirectoryFilter,\n\t\t\t\t\t\tentryFilter,\n\t\t\t\t\t\tparentPath: walkEntry.path,\n\t\t\t\t\t\tdepth: depth + 1,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\n\t\tyield* walk(dirPath, { directoryFilter, entryFilter });\n\t}\n\n\t/**\n\t * Returns the size of the given file.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number>} A promise that resolves with the size of the file.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be read.\n\t */\n\tasync size(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"size\", filePath);\n\t}\n\n\t/**\n\t * Returns the last modified timestamp of the given file or directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified date\n\t *  or undefined if the file or directory does not exist.\n\t * @throws {TypeError} If the path is not a string or URL.\n\t */\n\tasync lastModified(fileOrDirPath) {\n\t\tassertValidFileOrDirPath(fileOrDirPath);\n\t\treturn this.#callImplMethod(\"lastModified\", fileOrDirPath);\n\t}\n\n\t/**\n\t * Copys a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to the new file.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be copied.\n\t */\n\tasync copy(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copy\", source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be copied.\n\t */\n\tasync copyAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copyAll\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file or directory paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync move(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"move\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to move.\n\t * @param {string|URL} destination The path to move the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * moved.\n\t * @throws {TypeError} If the source is not a string or URL.\n\t * @throws {TypeError} If the destination is not a string or URL.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"moveAll\", source, destination);\n\t}\n}\n", "/**\n * @fileoverview The Path class.\n * @author Nicholas C. Zakas\n */\n\n/* globals URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef{import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef{import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes a path to use forward slashes.\n * @param {string} filePath The path to normalize.\n * @returns {string} The normalized path.\n */\nfunction normalizePath(filePath) {\n\tlet startIndex = 0;\n\tlet endIndex = filePath.length;\n\n\tif (/[a-z]:\\//i.test(filePath)) {\n\t\tstartIndex = 3;\n\t}\n\n\tif (filePath.startsWith(\"./\")) {\n\t\tstartIndex = 2;\n\t}\n\n\tif (filePath.startsWith(\"/\")) {\n\t\tstartIndex = 1;\n\t}\n\n\tif (filePath.endsWith(\"/\")) {\n\t\tendIndex = filePath.length - 1;\n\t}\n\n\treturn filePath.slice(startIndex, endIndex).replace(/\\\\/g, \"/\");\n}\n\n/**\n * Asserts that the given name is a non-empty string, no equal to \".\" or \"..\",\n * and does not contain a forward slash or backslash.\n * @param {string} name The name to check.\n * @returns {void}\n * @throws {TypeError} When name is not valid.\n */\nfunction assertValidName(name) {\n\tif (typeof name !== \"string\") {\n\t\tthrow new TypeError(\"name must be a string\");\n\t}\n\n\tif (!name) {\n\t\tthrow new TypeError(\"name cannot be empty\");\n\t}\n\n\tif (name === \".\") {\n\t\tthrow new TypeError(`name cannot be \".\"`);\n\t}\n\n\tif (name === \"..\") {\n\t\tthrow new TypeError(`name cannot be \"..\"`);\n\t}\n\n\tif (name.includes(\"/\") || name.includes(\"\\\\\")) {\n\t\tthrow new TypeError(\n\t\t\t`name cannot contain a slash or backslash: \"${name}\"`,\n\t\t);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nexport class Path {\n\t/**\n\t * The steps in the path.\n\t * @type {Array<string>}\n\t */\n\t#steps;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Iterable<string>} [steps] The steps to use for the path.\n\t * @throws {TypeError} When steps is not iterable.\n\t */\n\tconstructor(steps = []) {\n\t\tif (typeof steps[Symbol.iterator] !== \"function\") {\n\t\t\tthrow new TypeError(\"steps must be iterable\");\n\t\t}\n\n\t\tthis.#steps = [...steps];\n\t\tthis.#steps.forEach(assertValidName);\n\t}\n\n\t/**\n\t * Adds steps to the end of the path.\n\t * @param  {...string} steps The steps to add to the path.\n\t * @returns {void}\n\t */\n\tpush(...steps) {\n\t\tsteps.forEach(assertValidName);\n\t\tthis.#steps.push(...steps);\n\t}\n\n\t/**\n\t * Removes the last step from the path.\n\t * @returns {string} The last step in the path.\n\t */\n\tpop() {\n\t\treturn this.#steps.pop();\n\t}\n\n\t/**\n\t * Returns an iterator for steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\tsteps() {\n\t\treturn this.#steps.values();\n\t}\n\n\t/**\n\t * Returns an iterator for the steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\t[Symbol.iterator]() {\n\t\treturn this.steps();\n\t}\n\n\t/**\n\t * Retrieves the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#steps[this.#steps.length - 1];\n\t}\n\n\t/**\n\t * Sets the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tset name(value) {\n\t\tassertValidName(value);\n\t\tthis.#steps[this.#steps.length - 1] = value;\n\t}\n\n\t/**\n\t * Retrieves the size of the path.\n\t * @type {number}\n\t */\n\tget size() {\n\t\treturn this.#steps.length;\n\t}\n\n\t/**\n\t * Returns the path as a string.\n\t * @returns {string} The path as a string.\n\t */\n\ttoString() {\n\t\treturn this.#steps.join(\"/\");\n\t}\n\n\t/**\n\t * Creates a new path based on the argument type. If the argument is a string,\n\t * it is assumed to be a file or directory path and is converted to a Path\n\t * instance. If the argument is a URL, it is assumed to be a file URL and is\n\t * converted to a Path instance. If the argument is a Path instance, it is\n\t * copied into a new Path instance. If the argument is an array, it is assumed\n\t * to be the steps of a path and is used to create a new Path instance.\n\t * @param {string|URL|Path|Array<string>} pathish The value to convert to a Path instance.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When pathish is not a string, URL, Path, or Array.\n\t * @throws {TypeError} When pathish is a string and is empty.\n\t */\n\tstatic from(pathish) {\n\t\tif (typeof pathish === \"string\") {\n\t\t\tif (!pathish) {\n\t\t\t\tthrow new TypeError(\"argument cannot be empty\");\n\t\t\t}\n\n\t\t\treturn Path.fromString(pathish);\n\t\t}\n\n\t\tif (pathish instanceof URL) {\n\t\t\treturn Path.fromURL(pathish);\n\t\t}\n\n\t\tif (pathish instanceof Path || Array.isArray(pathish)) {\n\t\t\treturn new Path(pathish);\n\t\t}\n\n\t\tthrow new TypeError(\"argument must be a string, URL, Path, or Array\");\n\t}\n\n\t/**\n\t * Creates a new Path instance from a string.\n\t * @param {string} fileOrDirPath The file or directory path to convert.\n\t * @returns {Path} A new Path instance.\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromString(fileOrDirPath) {\n\t\treturn new Path(normalizePath(fileOrDirPath).split(\"/\"));\n\t}\n\n\t/**\n\t * Creates a new Path instance from a URL.\n\t * @param {URL} url The URL to convert.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When url is not a URL instance.\n\t * @throws {TypeError} When url.pathname is empty.\n\t * @throws {TypeError} When url.protocol is not \"file:\".\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromURL(url) {\n\t\tif (!(url instanceof URL)) {\n\t\t\tthrow new TypeError(\"url must be a URL instance\");\n\t\t}\n\n\t\tif (!url.pathname || url.pathname === \"/\") {\n\t\t\tthrow new TypeError(\"url.pathname cannot be empty\");\n\t\t}\n\n\t\tif (url.protocol !== \"file:\") {\n\t\t\tthrow new TypeError(`url.protocol must be \"file:\"`);\n\t\t}\n\n\t\t// Remove leading slash in pathname\n\t\treturn new Path(normalizePath(url.pathname.slice(1)).split(\"/\"));\n\t}\n}\n", "/**\n * @fileoverview Common error classes\n * @author Nicholas C. Zakas\n */\n\n/**\n * Error thrown when a file or directory is not found.\n */\nexport class NotFoundError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"NotFoundError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"ENOENT\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`ENOENT: No such file or directory, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when an operation is not permitted.\n */\nexport class PermissionError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"PermissionError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"EPERM\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`EPERM: Operation not permitted, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when an operation is not allowed on a directory.\n */\n\nexport class DirectoryError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"DirectoryError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"EISDIR\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`EISDIR: Illegal operation on a directory, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when a directory is not empty.\n */\nexport class NotEmptyError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"NotEmptyError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"ENOTEMPTY\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`ENOTEMPTY: Directory not empty, ${message}`);\n\t}\n}\n", "/**\n * @fileoverview API entrypoint for hfs/core\n * @author Nicholas C. Zakas\n */\n\nexport { Hfs } from \"./hfs.js\";\nexport { Path } from \"./path.js\";\nexport * from \"./errors.js\";\n", "// @ts-self-types=\"./retrier.d.ts\"\n/**\n * @fileoverview A utility for retrying failed async method calls.\n */\n\n/* global setTimeout, clearTimeout */\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst MAX_TASK_TIMEOUT = 60000;\nconst MAX_TASK_DELAY = 100;\nconst MAX_CONCURRENCY = 1000;\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Logs a message to the console if the DEBUG environment variable is set.\n * @param {string} message The message to log.\n * @returns {void}\n */\nfunction debug(message) {\n    if (globalThis?.process?.env.DEBUG === \"@hwc/retry\") {\n        console.debug(message);\n    }\n}\n\n/*\n * The following logic has been extracted from graceful-fs.\n *\n * The ISC License\n *\n * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\n * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * Checks if it is time to retry a task based on the timestamp and last attempt time.\n * @param {RetryTask} task The task to check.\n * @param {number} maxDelay The maximum delay for the queue.\n * @returns {boolean} true if it is time to retry, false otherwise.\n */\nfunction isTimeToRetry(task, maxDelay) {\n    const timeSinceLastAttempt = Date.now() - task.lastAttempt;\n    const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);\n    const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);\n\n    return timeSinceLastAttempt >= desiredDelay;\n}\n\n/**\n * Checks if it is time to bail out based on the given timestamp.\n * @param {RetryTask} task The task to check.\n * @param {number} timeout The timeout for the queue.\n * @returns {boolean} true if it is time to bail, false otherwise.\n */\nfunction isTimeToBail(task, timeout) {\n    return task.age > timeout;\n}\n\n/**\n * Creates a new promise with resolve and reject functions.\n * @returns {{promise:Promise<any>, resolve:(value:any) => any, reject: (value:any) => any}} A new promise.\n */\nfunction createPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n\n    let resolve, reject;\n\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n\n    if (resolve === undefined || reject === undefined) {\n        throw new Error(\"Promise executor did not initialize resolve or reject.\");\n    }\n\n    return { promise, resolve, reject };\n}\n\n\n/**\n * A class to represent a task in the retry queue.\n */\nclass RetryTask {\n\n    /**\n     * The unique ID for the task.\n     * @type {string}\n     */\n    id = Math.random().toString(36).slice(2);\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    fn;\n\n    /**\n     * The error that was thrown.\n     * @type {Error}\n     */\n    error;\n    \n    /**\n     * The timestamp of the task.\n     * @type {number}\n     */\n    timestamp = Date.now();\n\n    /**\n     * The timestamp of the last attempt.\n     * @type {number}\n     */\n    lastAttempt = this.timestamp;\n\n    /**\n     * The resolve function for the promise.\n     * @type {Function}\n     */\n    resolve;\n\n    /**\n     * The reject function for the promise.\n     * @type {Function}\n     */\n    reject;\n\n    /**\n     * The AbortSignal to monitor for cancellation.\n     * @type {AbortSignal|undefined}\n     */\n    signal;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} fn The function to call.\n     * @param {Error} error The error that was thrown.\n     * @param {Function} resolve The resolve function for the promise.\n     * @param {Function} reject The reject function for the promise.\n     * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.\n     */\n    constructor(fn, error, resolve, reject, signal) {\n        this.fn = fn;\n        this.error = error;\n        this.timestamp = Date.now();\n        this.lastAttempt = Date.now();\n        this.resolve = resolve;\n        this.reject = reject;\n        this.signal = signal;\n    }\n    \n    /**\n     * Gets the age of the task.\n     * @returns {number} The age of the task in milliseconds.\n     * @readonly\n     */\n    get age() {\n        return Date.now() - this.timestamp;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class that manages a queue of retry jobs.\n */\nclass Retrier {\n\n    /**\n     * Represents the queue for processing tasks.\n     * @type {Array<RetryTask>}\n     */\n    #retrying = [];\n\n    /**\n     * Represents the queue for pending tasks.\n     * @type {Array<Function>}\n     */\n    #pending = [];\n\n    /**\n     * The number of tasks currently being processed.\n     * @type {number}\n     */\n    #working = 0;\n\n    /**\n     * The timeout for the queue.\n     * @type {number}\n     */\n    #timeout;\n\n    /**\n     * The maximum delay for the queue.\n     * @type {number}\n     */\n    #maxDelay;\n\n    /**\n     * The setTimeout() timer ID.\n     * @type {NodeJS.Timeout|undefined}\n     */\n    #timerId;\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    #check;\n\n    /**\n     * The maximum number of concurrent tasks.\n     * @type {number}\n     */\n    #concurrency;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} check The function to call.\n     * @param {object} [options] The options for the instance.\n     * @param {number} [options.timeout] The timeout for the queue.\n     * @param {number} [options.maxDelay] The maximum delay for the queue.\n     * @param {number} [options.concurrency] The maximum number of concurrent tasks.\n     */\n    constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY, concurrency = MAX_CONCURRENCY } = {}) {\n\n        if (typeof check !== \"function\") {\n            throw new Error(\"Missing function to check errors\");\n        }\n\n        this.#check = check;\n        this.#timeout = timeout;\n        this.#maxDelay = maxDelay;\n        this.#concurrency = concurrency;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be retried.\n     * @returns {number} The number of tasks in the retry queue.\n     */\n    get retrying() {\n        return this.#retrying.length;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be processed in the pending queue.\n     * @returns {number} The number of tasks in the pending queue.\n     */\n    get pending() {\n        return this.#pending.length;\n    }\n\n    /**\n     * Gets the number of tasks currently being processed.\n     * @returns {number} The number of tasks currently being processed.\n     */\n    get working() {\n        return this.#working;\n    }\n\n    /**\n     * Calls the function and retries if it fails.\n     * @param {Function} fn The function to call.\n     * @param {Object} options The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @param {Promise<any>} options.promise The promise to return when the function settles.\n     * @param {Function} options.resolve The resolve function for the promise.\n     * @param {Function} options.reject The reject function for the promise.\n     * @returns {Promise<any>} A promise that resolves when the function is\n     * called successfully.\n     */\n    #call(fn, { signal, promise, resolve, reject }) {\n\n        let result;\n\n        try {\n            result = fn();\n        } catch (/** @type {any} */ error) {\n            reject(new Error(`Synchronous error: ${error.message}`, { cause: error }));\n            return promise;\n        }\n\n        // if the result is not a promise then reject an error\n        if (!result || typeof result.then !== \"function\") {\n            reject(new Error(\"Result is not a promise.\"));\n            return promise;\n        }\n\n        this.#working++;\n        promise.finally(() => {\n            this.#working--;\n            this.#processPending();\n        })\n        // `promise.finally` creates a new promise that may be rejected, so it must be handled.\n            .catch(() => { });\n\n        // call the original function and catch any ENFILE or EMFILE errors\n        Promise.resolve(result)\n            .then(value => {\n                debug(\"Function called successfully without retry.\");\n                resolve(value);\n            })\n            .catch(error => {\n                if (!this.#check(error)) {\n                    reject(error);\n                    return;\n                }\n\n                const task = new RetryTask(fn, error, resolve, reject, signal);\n                \n                debug(`Function failed, queuing for retry with task ${task.id}.`);\n                this.#retrying.push(task);\n\n                signal?.addEventListener(\"abort\", () => {\n                    debug(`Task ${task.id} was aborted due to AbortSignal.`);\n                    reject(signal.reason);\n                });\n\n                this.#processQueue();\n            });\n        \n        return promise;\n    }\n\n    /**\n     * Adds a new retry job to the queue.\n     * @template {(...args: unknown[]) => Promise<unknown>} Func\n     * @template {Awaited<ReturnType<Func>>} RetVal\n     * @param {Func} fn The function to call.\n     * @param {object} [options] The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @returns {Promise<RetVal>} A promise that resolves when the queue is processed.\n     */\n    retry(fn, { signal } = {}) {\n\n        signal?.throwIfAborted();\n\n        const { promise, resolve, reject } = createPromise();\n\n        this.#pending.push(() => this.#call(fn, { signal, promise, resolve, reject }));\n        this.#processPending();\n        \n        return promise;\n    }\n\n\n    /**\n     * Processes the pending queue and the retry queue.\n     * @returns {void}\n     */\n    #processAll() {\n        if (this.pending) {\n            this.#processPending();\n        }\n\n        if (this.retrying) {\n            this.#processQueue();\n        }\n    }\n\n    /**\n     * Processes the pending queue to see which tasks can be started.\n     * @returns {void}\n     */\n    #processPending() {\n\n        debug(`Processing pending tasks: ${this.pending} pending, ${this.working} working.`);\n\n        const available = this.#concurrency - this.working;\n\n        if (available <= 0) {\n            return;\n        }\n\n        const count = Math.min(this.pending, available);\n\n        for (let i = 0; i < count; i++) {\n            const task = this.#pending.shift();\n            task?.();\n        }\n\n        debug(`Processed pending tasks: ${this.pending} pending, ${this.working} working.`);\n    }\n\n    /**\n     * Processes the queue.\n     * @returns {void}\n     */\n    #processQueue() {\n        // clear any timer because we're going to check right now\n        clearTimeout(this.#timerId);\n        this.#timerId = undefined;\n\n        debug(`Processing retry queue: ${this.retrying} retrying, ${this.working} working.`);\n\n        const processAgain = () => {\n            this.#timerId = setTimeout(() => this.#processAll(), 0);\n        };\n\n        // if there's nothing in the queue, we're done\n        const task = this.#retrying.shift();\n        if (!task) {\n            debug(\"Queue is empty, exiting.\");\n\n            if (this.pending) {\n                processAgain();\n            }\n            return;\n        }\n\n        // if it's time to bail, then bail\n        if (isTimeToBail(task, this.#timeout)) {\n            debug(`Task ${task.id} was abandoned due to timeout.`);\n            task.reject(task.error);\n            processAgain();\n            return;\n        }\n\n        // if it's not time to retry, then wait and try again\n        if (!isTimeToRetry(task, this.#maxDelay)) {\n            debug(`Task ${task.id} is not ready to retry, skipping.`);\n            this.#retrying.push(task);\n            processAgain();\n            return;\n        }\n\n        // otherwise, try again\n        task.lastAttempt = Date.now();\n        \n        // Promise.resolve needed in case it's a thenable but not a Promise\n        Promise.resolve(task.fn())\n            // @ts-ignore because we know it's any\n            .then(result => {\n                debug(`Task ${task.id} succeeded after ${task.age}ms.`);\n                task.resolve(result);\n            })\n\n            // @ts-ignore because we know it's any\n            .catch(error => {\n                if (!this.#check(error)) {\n                    debug(`Task ${task.id} failed with non-retryable error: ${error.message}.`);\n                    task.reject(error);\n                    return;\n                }\n\n                // update the task timestamp and push to back of queue to try again\n                task.lastAttempt = Date.now();\n                this.#retrying.push(task);\n                debug(`Task ${task.id} failed, requeueing to try again.`);\n            })\n            .finally(() => {\n                this.#processAll();\n            });\n    }\n}\n\nexport { Retrier };\n", "/**\n * @fileoverview The main file for the hfs package.\n * @author Nicholas C. Zakas\n */\n/* global Buffer:readonly, URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"node:fs/promises\")} Fsp */\n/** @typedef {import(\"fs\").Dirent} Dirent */\n\n//-----------------------------------------------------------------------------\n// Imports\n//-----------------------------------------------------------------------------\n\nimport { Hfs } from \"@humanfs/core\";\nimport path from \"node:path\";\nimport { Retrier } from \"@humanwhocodes/retry\";\nimport nativeFsp from \"node:fs/promises\";\nimport { fileURLToPath } from \"node:url\";\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst RETRY_ERROR_CODES = new Set([\"ENFILE\", \"EMFILE\"]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a directory entry.\n * @implements {HfsDirectoryEntry}\n */\nclass NodeHfsDirectoryEntry {\n\t/**\n\t * The name of the directory entry.\n\t * @type {string}\n\t */\n\tname;\n\n\t/**\n\t * True if the entry is a file.\n\t * @type {boolean}\n\t */\n\tisFile;\n\n\t/**\n\t * True if the entry is a directory.\n\t * @type {boolean}\n\t */\n\tisDirectory;\n\n\t/**\n\t * True if the entry is a symbolic link.\n\t * @type {boolean}\n\t */\n\tisSymlink;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Dirent} dirent The directory entry to wrap.\n\t */\n\tconstructor(dirent) {\n\t\tthis.name = dirent.name;\n\t\tthis.isFile = dirent.isFile();\n\t\tthis.isDirectory = dirent.isDirectory();\n\t\tthis.isSymlink = dirent.isSymbolicLink();\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing the Node.js implementation of Hfs.\n * @implements {HfsImpl}\n */\nexport class NodeHfsImpl {\n\t/**\n\t * The file system module to use.\n\t * @type {Fsp}\n\t */\n\t#fsp;\n\n\t/**\n\t * The retryer object used for retrying operations.\n\t * @type {Retrier}\n\t */\n\t#retrier;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp = nativeFsp } = {}) {\n\t\tthis.#fsp = fsp;\n\t\tthis.#retrier = new Retrier(error => RETRY_ERROR_CODES.has(error.code));\n\t}\n\n\t/**\n\t * Reads a file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\n\t *    of the file or undefined if the file doesn't exist.\n\t * @throws {Error} If the file cannot be read.\n\t * @throws {TypeError} If the file path is not a string.\n\t */\n\tbytes(filePath) {\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.readFile(filePath))\n\t\t\t.then(buffer => new Uint8Array(buffer.buffer))\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to write.\n\t * @param {Uint8Array} contents The contents to write to the\n\t *   file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t *  written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be written.\n\t */\n\tasync write(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.writeFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.writeFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Appends a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to append to.\n\t * @param {Uint8Array} contents The contents to append to the\n\t *  file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t * written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.appendFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.appendFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a file exists.\n\t * @param {string|URL} filePath The path to the file to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    file exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisFile(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.isFile())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a directory exists.\n\t * @param {string|URL} dirPath The path to the directory to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    directory exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisDirectory(dirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(dirPath)\n\t\t\t.then(stat => stat.isDirectory())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates a directory recursively.\n\t * @param {string|URL} dirPath The path to the directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is\n\t *   created.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tawait this.#fsp.mkdir(dirPath, { recursive: true });\n\t}\n\n\t/**\n\t * Deletes a file or empty directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdelete(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath)\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ERR_FS_EISDIR\") {\n\t\t\t\t\treturn this.#fsp.rmdir(fileOrDirPath).then(() => true);\n\t\t\t\t}\n\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Deletes a file or directory recursively.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdeleteAll(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath, { recursive: true })\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tconst entries = await this.#fsp.readdir(dirPath, {\n\t\t\twithFileTypes: true,\n\t\t});\n\n\t\tfor (const entry of entries) {\n\t\t\tyield new NodeHfsDirectoryEntry(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the size of a file. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number|undefined>} A promise that resolves with the size of the\n\t *  file in bytes or undefined if the file doesn't exist.\n\t */\n\tsize(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.size)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns the last modified date of a file or directory. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} fileOrDirPath The path to the file to read.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified\n\t * date of the file or directory, or undefined if the file doesn't exist.\n\t */\n\tlastModified(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(fileOrDirPath)\n\t\t\t.then(stat => stat.mtime)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Copies a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to copy the file to.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {Error} If the source file does not exist.\n\t * @throws {Error} If the source file is a directory.\n\t * @throws {Error} If the destination file is a directory.\n\t */\n\tcopy(source, destination) {\n\t\treturn this.#fsp.copyFile(source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {Error} If the source file or directory does not exist.\n\t * @throws {Error} If the destination file or directory is a directory.\n\t */\n\tasync copyAll(source, destination) {\n\t\t// for files use copy() and exit\n\t\tif (await this.isFile(source)) {\n\t\t\treturn this.copy(source, destination);\n\t\t}\n\n\t\tconst sourceStr =\n\t\t\tsource instanceof URL ? fileURLToPath(source) : source;\n\n\t\tconst destinationStr =\n\t\t\tdestination instanceof URL\n\t\t\t\t? fileURLToPath(destination)\n\t\t\t\t: destination;\n\n\t\t// for directories, create the destination directory and copy each entry\n\t\tawait this.createDirectory(destination);\n\n\t\tfor await (const entry of this.list(source)) {\n\t\t\tconst fromEntryPath = path.join(sourceStr, entry.name);\n\t\t\tconst toEntryPath = path.join(destinationStr, entry.name);\n\n\t\t\tif (entry.isDirectory) {\n\t\t\t\tawait this.copyAll(fromEntryPath, toEntryPath);\n\t\t\t} else {\n\t\t\t\tawait this.copy(fromEntryPath, toEntryPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file cannot be moved.\n\t */\n\tmove(source, destination) {\n\t\treturn this.#fsp.stat(source).then(stat => {\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`EISDIR: illegal operation on a directory, move '${source}' -> '${destination}'`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.#fsp.rename(source, destination);\n\t\t});\n\t}\n\n\t/**\n\t * Moves a file or directory from the source path to the destination path.\n\t * @param {string|URL} source The location of the file or directory to move.\n\t * @param {string|URL} destination The destination of the file or directory to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\treturn this.#fsp.rename(source, destination);\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class NodeHfs extends Hfs {\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp } = {}) {\n\t\tsuper({ impl: new NodeHfsImpl({ fsp }) });\n\t}\n}\n\nexport const hfs = new NodeHfs();\n", "/**\n * @fileoverview This file exports everything for this package.\n * @author Nicholas C. Zakas\n */\n\nexport * from \"./node-hfs.js\";\nexport { Hfs } from \"@humanfs/core\";\n"],
  "mappings": "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",
  "names": ["dirPath", "directoryFilter", "entryFilter", "nativeFsp", "path", "init_src"]
}
